---
layout: post
title: REvil Part Two - Decryption With RC4
---

We know which function generates the parameters for decryption. Now onto the decryption itself. 

Decrypt_strings_wrapper allows REvil to decrypt strings in a non-linear manner. Once the parameters are generated within the wrapper, they are passed onto another function to perform the decryption process. Decrypt_strings and its child functions are the focus for this post.

![REvil decryption functions]({{ site.baseurl }}/images/decryption_functions.png)

The purpose of this post is to aid recognition of RC4 when debugging malware, plus build an understanding of the algorithm itself. 

### Stream Ciphers and Symmetric Cryptography
Stream ciphers (RC4 being one of them) operate by generating a pseudo-random “keystream” which is XORed against each byte of the encrypted text (or against the plain text to create the cipher text). Generating the keystream is dependent on the key, hence each keystream should be unique. 

Furthermore, RC4 is a symmetric cryptographic algorithm; the same key is used for both encryption and decryption. Therefore, a main challenge for this algorithm is how the key can be shared between parties. In the case of malware, a further challenge is how that key can be shared without making it easy for the analyst to recover. 

During the first post we already discovered how REvil includes the RC4 key appended to each piece of encrypted string. Using a unique key for each string makes it slightly more difficult to automate but that will be covered later. For now, let us focus on the algorithm itself. 

### RC4 in REvil

RC4 is implemented using a two functions in REvil. Firstly, a keystream is generated by generate_key_schedule, the keystream is then passed to the second function (string_decrypt). Further modification of the keystream occurs, followed by the XOR of a byte from the keystream against the ciphertext. Each XOR operation reveals the plaintext. 

#### Generate Keystream

The first call to start the RC4 decryption is to generate_key_schedule(0x00412DC3). Three parameters are passed:

1. Pointer to buffer to receive key schedule algorithm (keystream)
2. Pointer to the key
3. Key length

Creating and initialising the keystream is done with a "Key Schedule Algorithm", which is made up of two loops:

```for i from 0 to 255
    S[i] := i
endfor
j := 0
for i from 0 to 255
    j := (j + S[i] + key[i mod,  keylength]) mod 256
    swap values of S[i] and S[j]
endfor
```






