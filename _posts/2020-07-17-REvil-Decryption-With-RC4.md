---
layout: post
title: REvil Part Two - Decryption With RC4
---

We know which function generates the parameters for decryption. Now onto the decryption itself. 

Decrypt_strings_wrapper allows REvil to decrypt strings in a non-linear manner. Once the parameters are generated within the wrapper, they are passed onto another function to perform the decryption process. Decrypt_strings and its child functions are the focus for this post.

![REvil decryption functions]({{ site.baseurl }}/images/decryption_functions.png)

The purpose of this post is to aid recognition of RC4 when debugging malware, plus build an understanding of the algorithm itself. 

### Stream Ciphers and Symmetric Cryptography
Stream ciphers (RC4 being one of them) operate by generating a pseudo-random “keystream” which is XORed against each byte of the encrypted text (or against the plain text to create the cipher text). Generating the keystream is dependent on the key, hence each keystream should be unique. 

Furthermore, RC4 is a symmetric cryptographic algorithm; the same key is used for both encryption and decryption. Therefore, a main challenge for this algorithm is how the key can be shared between parties. In the case of malware, a further challenge is how that key can be shared without making it easy for the analyst to recover. 

During the first post we already discovered how REvil includes the RC4 key appended to each piece of encrypted string. Using a unique key for each string makes it slightly more difficult to automate but that will be covered later. For now, let us focus on the algorithm itself. 

### RC4 in REvil

RC4 is implemented using a two functions in REvil. Firstly, a keystream is generated by generate_key_schedule, the keystream is then passed to the second function (string_decrypt). Further modification of the keystream occurs, followed by the XOR of a byte from the keystream against the ciphertext. Each XOR operation reveals the plaintext. 

#### Generate Keystream

The first call to start the RC4 decryption is to generate_key_schedule(0x00412DC3). Three parameters are passed:

1. Pointer to buffer to receive key schedule algorithm (keystream)
2. Pointer to the key
3. Key length

Creating and initialising the keystream is done with a "Key Schedule Algorithm", which is made up of two loops:

```for i from 0 to 255
    S[i] := i
    
endfor
j := 0
for i from 0 to 255
    j := (j + S[i] + key[i mod,  keylength]) mod 256
    swap values of S[i] and S[j]
endfor
```

Firstly, an array is created with values from 0 to 255. By looking for an instruction comparing a counter to 255 (or below 256\0x100) is evidence of this array (and that RC4 is implemented). This array is referred to as S in the pseudocode above and what this looks like in a debugger is below:

![REvil initialising S array in RC4]({{ site.baseurl }}/images/first_loop_RC4.png)

In this first loop, EDI holds the first parameter (buffer that receives the S array) and EAX is used as both a counter and the value “I”. Initialising EAX to 0, the lowest byte of EAX (denoted by al) is moved into S[i]:

![Build from 0-255]({{ site.baseurl }}/images/initialise_S_array.png)

EAX is incremented by 1 and compared to 0x100 (2565), if it is below then it jumps up to that mov instruction again. This simple builds out the initial S array:

![Completed S array]({{ site.baseurl }}/images/complete_S_array.png)




