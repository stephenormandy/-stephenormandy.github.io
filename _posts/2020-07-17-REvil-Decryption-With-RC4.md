---
layout: post
title: REvil Part Two - Decryption With RC4
---

We know which function generates the parameters for decryption. Now onto the decryption itself. 

Decrypt_strings_wrapper allows REvil to decrypt strings in a non-linear manner. Once the parameters are generated within the wrapper, they are passed onto another function to perform the decryption process. Decrypt_strings and its child functions are the focus for this post.

![REvil decryption functions]({{ site.baseurl }}/images/decryption_functions.png)

The purpose of this post is to aid recognition of RC4 when debugging malware, plus build an understanding of the algorithm itself. 

### Stream Ciphers and Symmetric Cryptography
Stream ciphers (RC4 being one of them) operate by generating a pseudo-random “keystream” which is XORed against each byte of the encrypted text (or against the plain text to create the cipher text). Generating the keystream is dependent on the key, hence each keystream should be unique. 

Furthermore, RC4 is a symmetric cryptographic algorithm; the same key is used for both encryption and decryption. Therefore, a main challenge for this algorithm is how the key can be shared between parties. In the case of malware, a further challenge is how that key can be shared without making it easy for the analyst to recover. 

During the first post we already discovered how REvil includes the RC4 key appended to each piece of encrypted string. Using a unique key for each string makes it slightly more difficult to automate but that will be covered later. For now, let us focus on the algorithm itself. 

### RC4 in REvil

RC4 is implemented using a two functions in REvil. Firstly, a keystream is generated by generate_key_schedule, the keystream is then passed to the second function (string_decrypt). Further modification of the keystream occurs, followed by the XOR of a byte from the keystream against the ciphertext. Each XOR operation reveals the plaintext. 

#### Generate Keystream

The first call to start the RC4 decryption is to generate_key_schedule(0x00412DC3). Three parameters are passed:

1. Pointer to buffer to receive key schedule algorithm (keystream)
2. Pointer to the key
3. Key length

Creating and initialising the keystream is done with a "Key Schedule Algorithm", which is made up of two loops:

```
for i from 0 to 255
        S[i] := i
endfor
j := 0
for i from 0 to 255
        j := (j + S[i] + key[i mod,  keylength]) mod 256
        swap values of S[i] and S[j]
endfor
```


Firstly, an array is created with values from 0 to 255. By looking for an instruction comparing a counter to 255 (or below 256\0x100) is evidence of this array (and that RC4 is implemented). This array is referred to as S in the pseudocode above and what this looks like in a debugger is below:

![REvil initialising S array in RC4]({{ site.baseurl }}/images/first_loop_RC4.png)

In this first loop, EDI holds the first parameter (buffer that receives the S array) and EAX is used as both a counter and the value “I”. Initialising EAX to 0, the lowest byte of EAX (denoted by al) is moved into S[i]:

![Build from 0-255]({{ site.baseurl }}/images/initialise_S_array.png)

EAX is incremented by 1 and compared to 0x100 (2565), if it is below then it jumps up to that mov instruction again. This simple builds out the initial S array:

![Completed S array]({{ site.baseurl }}/images/complete_S_array.png)

The second loop of the key schedule algorithm is used to swap values around based on the key and it’s length (hence why both were parameters for this function). 

![Swapping values in the S array]({{ site.baseurl }}/images/swapping_values_S_array.png)

To make the maths operations slightly easier to follow, the loop has been run twice already. Therefore, our counter “i” is set to 2 (also remember that counting positions in of arrays is done from 0, here 2 would equate to the third position). 

ECX is used to store the i value, which is also copied into EAX. The value of S[i] is placed into the lowest byte of EBX (noted by bl), then copied into ECX:

![Initialise the second loop of the KSA]({{ site.baseurl }}/images/initialise_second_loop.png)

A div command with an operand of the value at ebp+10, the key length, is the equivalent of the “i mod keylength” operation to get a value from the key:

![Calculate value to retrieve from the key]({{ site.baseurl }}/images/retrieve_value_from_key.png)

The div command works by concatenating the two values of EDX to EAX (making a 64bit number) and dividing it by the operand given. In this case the equation would be:

0000000000000002 / 0xA (10) = 0 remainder 2

That remainder value is stored in EDX and the whole value stored in EAX. As a modulo calculation is akin to dividing the number by its modulo and taking the remainder, the instruction at 0x00412DF1 uses EDX to get a pointer into the key. So, it retrieves the third position in the key and stores it in EAX:

![Instruction to retrieve value from key]({{ site.baseurl }}/images/div_result_1.png)

![Value from key in memory]({{ site.baseurl }}/images/div_result_2.png)

![Value from key in EAX]({{ site.baseurl }}/images/div_result_3.png)

J is then added to key[2], subsequently that is added to S[i], which completes the main line in this loop of forming the value j:

![Final instruction to formulate value of j]({{ site.baseurl }}/images/forming_j.png)

Finally, the values of S[j] and S[i] are swapped:

![Swapping values of s and j in S array]({{ site.baseurl }}/images/swap_s_j.png)

![Swapping values of s and j in S array]({{ site.baseurl }}/images/swap_s_j_2.png)

Values at positions S[2] and S[7] were swapped over. 

It repeats this loop until ECX/i is no longer below 0x100 (255). From what was a uniform array now turns into a jumble:

![Completed KSA]({{ site.baseurl }}/images/completed_KSA.png)

The address of S is returned to decrypt_strings where string_decrypt is then called. String_decrypt requires the parameters of the plaintext length, the buffer for storage, cipher text and the S array. The functionality here is referred to as the Pseudo-random generation algorithm. Essentially it modifies the S array further and then outputs a keystream value that cipher text will be XORed against. Pseudocode is below:

```
i := 0
j := 0
while GeneratingOutput:
    i := (i + 1) mod 256
    j := (j + S[i]) mod 256
    swap values of S[i] and S[j]
    K := S[(S[i] + S[j]) mod 256]
    output K
endwhile
```
This loop begins at 0x00412E32:

![Second stage of RC4]({{ site.baseurl }}/images/rc4_stage_2.png)

A pointer to the S array is stored in EDX, i is incremented by 1 and set in EAX:

![Initialise second stage]({{ site.baseurl }}/images/initialise_stage_2.png)

j is then added to the S[i] value in EAX:

![Create j value in second stage]({{ site.baseurl }}/images/stage_2_set_j.png)

Values at S[i] and S[j] are swapped around, the new value of S[i] is copied into EAX once again:

![Create j value in second stage]({{ site.baseurl }}/images/stage_2_swap_i_j.png)

S[j] and S[i] are added to get a new pointer into S, stored in EAX. This is the keystream value which is XORed against the cipher text to get the plaintext value. The plaintext character in EAX is moved into the plaintext buffer, the buffer address is increased by 1 to find the next available position, the length of plaintext is decremented by 1 and if not equal to zero repeats the process:  

![XOR to reveal plaintext]({{ site.baseurl }}/images/stage_2_xor.png)

Plaintext is now revealed:

![Plaintext]({{ site.baseurl }}/images/plaintext.png)

### Summary

By looking for two consecutive loops, with the first one being executed 255 times, RC4 is a relatively easy algorithm to identify. While it may be intimidating at first, RC4 is also a simple algorithm. Matching the pseudocode of the algorithm to x86 assembly, it is possible to understand just how it decrypts strings within REvil. With that understanding, the final post of this series will layout how the decryption process can be automated within Ghidra. 



